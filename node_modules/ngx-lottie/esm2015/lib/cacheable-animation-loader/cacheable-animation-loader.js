import { Injectable } from '@angular/core';
import { map } from 'rxjs/operators';
import { AnimationLoader } from '../animation-loader';
export class CacheableAnimationLoader extends AnimationLoader {
    constructor() {
        super(...arguments);
        this.cache = new Map();
    }
    loadAnimation(options) {
        return this.player$.pipe(map(player => {
            const animationItem = this.createAnimationItem(player, this.transformOptions(options));
            this.awaitConfigAndCache(options, animationItem);
            return animationItem;
        }));
    }
    awaitConfigAndCache(options, animationItem) {
        if (this.isAnimationConfigWithPath(options)) {
            // Don't wait for the `config_ready` event if it has been cached previously.
            if (this.cache.has(options.path)) {
                return;
            }
            animationItem.addEventListener('config_ready', () => {
                this.cache.set(options.path, animationItem['animationData']);
            });
        }
    }
    transformOptions(options) {
        if (this.isAnimationConfigWithPath(options) && this.cache.has(options.path)) {
            return Object.assign(Object.assign({}, options), { path: undefined, animationData: this.cache.get(options.path) });
        }
        else {
            return options;
        }
    }
    isAnimationConfigWithPath(options) {
        return typeof options.path === 'string';
    }
}
CacheableAnimationLoader.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=cacheable-animation-loader.js.map